<?php

require_once drupal_get_path('module', 'delicious_backup') . '/Files/JSLikeHTMLElement.php';
require_once drupal_get_path('module', 'delicious_backup') . '/Files/DeliciousBackup.class.php';
require_once drupal_get_path('module', 'delicious_backup') . '/Files/Readability.php';
require_once drupal_get_path('module', 'delicious_backup') . '/Files/url_to_absolute.merge.php';

// hooks
require_once drupal_get_path('module', 'delicious_backup') . '/delicious_backup.hooks.inc';
require_once drupal_get_path('module', 'delicious_backup') . '/delicious_backup.drush.inc';

function delicious_backup_bookmark_access($node) {
  return $node->type == 'delicious_bookmark' && user_access('view content');
}

function _delicious_back_preload2(&$content) {
  
  #if (preg_match("/<code>.*(<br(|\s*\/)>).*<\/code>/m", $content, $res)) {
  #  $content = preg_replace("/(<br(|\s*\/)>)/", "\n", $content);
  #}  

  #drupal_add_css('code { white-space: pre; background-color:red;} ', 'inline');
  
}

function _delicious_back_preload(&$content) {
  
  //check for external gist scripts
  if (!preg_match_all('@<script src="(http://gist.github.com/(\d+).js)"></script>@i', $content, $match, PREG_SET_ORDER))
    return;

  // walk through all javascript code snippets
  foreach ($match as $git_code) {

    // request javascript file and filter out code
    $req = drupal_http_request($git_code[1]);
    if (isset($req->data) AND preg_match('@<a href="(.*gist\.github.*)"[ ]@i', stripslashes($req->data), $res)) {
      $req1 = drupal_http_request($res[1]);
      
      // replace external javascript file with raw source code
      if (isset($req1->data)) {
        $content = str_replace($git_code[0], '<pre>' . htmlentities($req1->data) . '</pre>', $content);
      }
     
    }
  }
}

/**
 * Implements hook_delicious_backup_updated().
 */
function delicious_backup_delicious_backup_updated($bid) {

  // create a worker for update content
  $queue = DrupalQueue::get('delicious_backup_update_node') ;
  $queue->createQueue();
  $queue->createItem($bid);
}

function _delicious_backup_full_worker() {
  /* queue workers */
  $queue = DrupalQueue::get('delicious_backup_get_content');
  while ($item = $queue->claimItem(15)) {
    delicious_backup_get_content($item->data);
    $queue->deleteItem($item);
  }  
  
  /* queue workers */
  $queue = DrupalQueue::get('delicious_backup_update_node');
  while ($item = $queue->claimItem(15)) {
    delicious_backup_update_node($item->data);
    $queue->deleteItem($item);
  }     
}

function delicious_backup_update_node($obj, $getimages = false) {
  
  try {

    if (is_numeric($obj)) $obj = db_query("SELECT nid,bid,hash,href FROM {delicious_bookmarks_backup} WHERE bid = :bid", array(':bid' => $obj))->fetchObject();
    
    $test = new Reader($obj->nid);
    $test->UpdateNode();
    
  
  } catch (Exception $e) {
    watchdog('delicious_backup', 'error on bid: ' . $obj->bid . ' ' . $e->getMessage());
    return false;
  }  
  
}

function delicious_backup_import_bookmarks() {

  $vid = taxonomy_vocabulary_machine_name_load('delicious_backup_tags')->vid;

  // load bookmarks from delicious
  if (!$bookmarks = DeliciousBackup::GetResponse('posts/all?')) {
    watchdog('delicious_backup', 'could not import bookmarks from delicous'); 
    return false;
  }
  
  $xml = new SimpleXMLElement($bookmarks);

  $new = 0;
  foreach ($xml->post as $post) {
    
    // dont work on private links
    if (!isset($post['shared']) AND (string) $post['shared'] != 'no') {

      // import bookmark
      db_merge('delicious_bookmarks_backup')
        ->key(array('hash' => (string) $post['hash']))
        ->fields(array(
            'href' => (string) $post['href'],
            'meta' => (string) $post['meta'],
            'description' => (string) $post['description'],
            'time' => strtotime((string) $post['time']),
            'extended' => (string) $post['extended'],
            'tag' => (string) $post['tag'],
            'last_found' => time(),
        ))
        ->execute();

      // get bookmarks
      $obj = db_query("SELECT nid,bid FROM {delicious_bookmarks_backup} WHERE hash = :hash", array(':hash' => (string) $post['hash']))->fetchAssoc();

      // import tags to terms
      $categories = _delicious_backup_taxonomie_helper(explode(' ', $post['tag']),  $vid);

      if ($obj['nid'] == 0) {

        $node = new stdClass();
        $node->type = 'delicious_bookmark';
        $node->language = LANGUAGE_NONE;

        node_object_prepare($node);
        $node->title = (string) $post['description'];
        $node->delicious_backup_tags[LANGUAGE_NONE] = $categories;
        $node->created = strtotime((string) $post['time']);

        node_save($node);

        db_update('delicious_bookmarks_backup')
          ->fields(array('nid' => $node->nid, 'last_found' => time()))
          ->condition('hash', (string) $post['hash'])
          ->execute();
        
        watchdog('delicious_backup', 'New node %bid', array('%bid' => $obj['bid']));

        $new++;

      } else {

        if ($node = node_load($obj['nid'])) {
          $node->delicious_backup_tags[LANGUAGE_NONE] = $categories;
          $node->created = strtotime((string) $post['time']);
          
          node_save($node);
        } else {
          watchdog('delicious_backup', 'Resetting Bookmark %bid ', array('%bid' => $obj['bid']));
          db_update('delicious_bookmarks_backup')->fields(array('nid' => 0))->condition('bid', $obj['bid'])->execute();          
        }

      }
   }
  }

  if ($new > 0) watchdog('delicious_backup', 'New %count Bookmark(s) Imported', array('%count' => $new));

}

function _delicious_backup_taxonomie_helper($term_name, $vid) {

  // first paramter can be string or array
  if (is_string($term_name)) $term_name = array($term_name);

  $b = array();
  foreach($term_name as $term_str) {

    // look for term and filter it by vocabulary; sry not in drupal core
    if ($terms = taxonomy_get_term_by_name($term_str)) {
      foreach($terms as $term) {
        if ($term->vid == $vid) $b[] = array('tid' => $term->tid);
     }

    } else {

      // create a new term
      $edit = array(
        'name' => $term_str,
        'description' => '',
        'parent' => array(0),
        'vid' =>  $vid,
      );

      $term = (object) $edit;
      taxonomy_term_save($term);
      $b[] = array('tid' => $term->tid);

    }
  }

  return $b;
}

function delicious_backup_get_content($link) {

  if (is_numeric($link)) $link = db_query("SELECT bid, hash, href FROM {delicious_bookmarks_backup} WHERE bid = :bid", array(':bid' => $link))->fetchObject();
  
  $test = new Reader($link->nid);
  $test->UpdateNode();

}

function delicious_backup_get_valid_bookmarks() {
  return db_select('delicious_bookmarks_backup')
    ->fields('delicious_bookmarks_backup', array('bid', 'hash', 'href', 'nid'))
    ->condition('response_code', 200)
    #->condition('bid', 1340)
    ->orderBy('bid')
    ->execute();
}

?>